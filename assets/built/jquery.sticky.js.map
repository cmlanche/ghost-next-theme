{"version":3,"sources":["jquery.sticky.js"],"names":["factory","define","amd","module","exports","require","jQuery","$","scroller","scrollTop","$window","documentHeight","$document","height","dwh","windowHeight","extra","i","l","sticked","length","s","etse","stickyWrapper","offset","top","topSpacing","css","stickyElement","outerHeight","currentTop","width","position","parent","removeClass","className","trigger","newWidth","newTop","bottomSpacing","getWidthFrom","widthFromWrapper","addClass","resizer","responsiveWidth","slice","Array","prototype","splice","defaults","wrapperClassName","center","window","document","methods","init","options","o","extend","this","each","stickyId","attr","stickyHeight","wrapperId","wrapper","wrapAll","outerWidth","marginLeft","marginRight","float","push","update","unstick","unstickyElement","removeIdx","get","call","unwrap","addEventListener","attachEvent","fn","sticky","method","apply","arguments","error","setTimeout"],"mappings":"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","file":"jquery.sticky.js","sourcesContent":["// Sticky Plugin v1.0.3 for jQuery\n// =============\n// Author: Anthony Garand\n// Improvements by German M. Bravo (Kronuz) and Ruud Kamphuis (ruudk)\n// Improvements by Leonardo C. Daronco (daronco)\n// Created: 02/14/2011\n// Date: 07/20/2015\n// Website: http://stickyjs.com/\n// Description: Makes an element on the page stick on the screen as you scroll\n//              It will only set the 'top' and 'position' of your element, you\n//              might need to adjust the width in some cases.\n\n(function (factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(jQuery);\n    }\n}(function ($) {\n    var slice = Array.prototype.slice; // save ref to original slice()\n    var splice = Array.prototype.splice; // save ref to original slice()\n\n  var defaults = {\n      topSpacing: 0,\n      bottomSpacing: 0,\n      className: 'is-sticky',\n      wrapperClassName: 'sticky-wrapper',\n      center: false,\n      getWidthFrom: '',\n      widthFromWrapper: true, // works only when .getWidthFrom is empty\n      responsiveWidth: false\n    },\n    $window = $(window),\n    $document = $(document),\n    sticked = [],\n    windowHeight = $window.height(),\n    scroller = function() {\n      var scrollTop = $window.scrollTop(),\n        documentHeight = $document.height(),\n        dwh = documentHeight - windowHeight,\n        extra = (scrollTop > dwh) ? dwh - scrollTop : 0;\n\n      for (var i = 0, l = sticked.length; i < l; i++) {\n        var s = sticked[i],\n          elementTop = s.stickyWrapper.offset().top,\n          etse = elementTop - s.topSpacing - extra;\n\n\t//update height in case of dynamic content\n\ts.stickyWrapper.css('height', s.stickyElement.outerHeight());\n\n        if (scrollTop <= etse) {\n          if (s.currentTop !== null) {\n            s.stickyElement\n              .css({\n                'width': '',\n                'position': '',\n                'top': ''\n              });\n            s.stickyElement.parent().removeClass(s.className);\n            s.stickyElement.trigger('sticky-end', [s]);\n            s.currentTop = null;\n          }\n        }\n        else {\n          var newTop = documentHeight - s.stickyElement.outerHeight()\n            - s.topSpacing - s.bottomSpacing - scrollTop - extra;\n          if (newTop < 0) {\n            newTop = newTop + s.topSpacing;\n          } else {\n            newTop = s.topSpacing;\n          }\n          if (s.currentTop !== newTop) {\n            var newWidth;\n            if (s.getWidthFrom) {\n                newWidth = $(s.getWidthFrom).width() || null;\n            } else if (s.widthFromWrapper) {\n                newWidth = s.stickyWrapper.width();\n            }\n            if (newWidth == null) {\n                newWidth = s.stickyElement.width();\n            }\n            s.stickyElement\n              .css('width', newWidth)\n              .css('position', 'fixed')\n              .css('top', newTop);\n\n            s.stickyElement.parent().addClass(s.className);\n\n            if (s.currentTop === null) {\n              s.stickyElement.trigger('sticky-start', [s]);\n            } else {\n              // sticky is started but it have to be repositioned\n              s.stickyElement.trigger('sticky-update', [s]);\n            }\n\n            if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) {\n              // just reached bottom || just started to stick but bottom is already reached\n              s.stickyElement.trigger('sticky-bottom-reached', [s]);\n            } else if(s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) {\n              // sticky is started && sticked at topSpacing && overflowing from top just finished\n              s.stickyElement.trigger('sticky-bottom-unreached', [s]);\n            }\n\n            s.currentTop = newTop;\n          }\n        }\n      }\n    },\n    resizer = function() {\n      windowHeight = $window.height();\n\n      for (var i = 0, l = sticked.length; i < l; i++) {\n        var s = sticked[i];\n        var newWidth = null;\n        if (s.getWidthFrom) {\n            if (s.responsiveWidth) {\n                newWidth = $(s.getWidthFrom).width();\n            }\n        } else if(s.widthFromWrapper) {\n            newWidth = s.stickyWrapper.width();\n        }\n        if (newWidth != null) {\n            s.stickyElement.css('width', newWidth);\n        }\n      }\n    },\n    methods = {\n      init: function(options) {\n        var o = $.extend({}, defaults, options);\n        return this.each(function() {\n          var stickyElement = $(this);\n\n          var stickyId = stickyElement.attr('id');\n          var stickyHeight = stickyElement.outerHeight();\n          var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName;\n          var wrapper = $('<div></div>')\n            .attr('id', wrapperId)\n            .addClass(o.wrapperClassName);\n\n          stickyElement.wrapAll(wrapper);\n\n          var stickyWrapper = stickyElement.parent();\n\n          if (o.center) {\n            stickyWrapper.css({width:stickyElement.outerWidth(),marginLeft:\"auto\",marginRight:\"auto\"});\n          }\n\n          if (stickyElement.css(\"float\") === \"right\") {\n            stickyElement.css({\"float\":\"none\"}).parent().css({\"float\":\"right\"});\n          }\n\n          stickyWrapper.css('height', stickyHeight);\n\n          o.stickyElement = stickyElement;\n          o.stickyWrapper = stickyWrapper;\n          o.currentTop    = null;\n\n          sticked.push(o);\n        });\n      },\n      update: scroller,\n      unstick: function(options) {\n        return this.each(function() {\n          var that = this;\n          var unstickyElement = $(that);\n\n          var removeIdx = -1;\n          var i = sticked.length;\n          while (i-- > 0) {\n            if (sticked[i].stickyElement.get(0) === that) {\n                splice.call(sticked,i,1);\n                removeIdx = i;\n            }\n          }\n          if(removeIdx !== -1) {\n            unstickyElement.unwrap();\n            unstickyElement\n              .css({\n                'width': '',\n                'position': '',\n                'top': '',\n                'float': ''\n              })\n            ;\n          }\n        });\n      }\n    };\n\n  // should be more efficient than using $window.scroll(scroller) and $window.resize(resizer):\n  if (window.addEventListener) {\n    window.addEventListener('scroll', scroller, false);\n    window.addEventListener('resize', resizer, false);\n  } else if (window.attachEvent) {\n    window.attachEvent('onscroll', scroller);\n    window.attachEvent('onresize', resizer);\n  }\n\n  $.fn.sticky = function(method) {\n    if (methods[method]) {\n      return methods[method].apply(this, slice.call(arguments, 1));\n    } else if (typeof method === 'object' || !method ) {\n      return methods.init.apply( this, arguments );\n    } else {\n      $.error('Method ' + method + ' does not exist on jQuery.sticky');\n    }\n  };\n\n  $.fn.unstick = function(method) {\n    if (methods[method]) {\n      return methods[method].apply(this, slice.call(arguments, 1));\n    } else if (typeof method === 'object' || !method ) {\n      return methods.unstick.apply( this, arguments );\n    } else {\n      $.error('Method ' + method + ' does not exist on jQuery.sticky');\n    }\n  };\n  $(function() {\n    setTimeout(scroller, 0);\n  });\n}));\n"]}